name: Scheduled ETL (Odds + Results)

on:
  # run automatically when you push to this branch (for migration/testing)
  push:
    branches: [fullstack-migration]

  # scheduled runs only trigger from the repo default branch (usually main)
  schedule:
    - cron: "5 14 * * *"
    - cron: "5 13 * * *"
    - cron: "5 8 * * *"
    - cron: "5 7 * * *"

  workflow_dispatch:
    inputs:
      task:
        description: "Which task to run?"
        required: true
        default: "odds"
        type: choice
        options:
          - odds
          - results

permissions:
  contents: write

concurrency:
  group: scheduled-etl
  cancel-in-progress: false

jobs:
  etl:
    runs-on: ubuntu-latest

    env:
      DB_PATH: ${{ github.workspace }}/data/demo_odds.sqlite

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # ensure we operate on the triggering branch/ref
          ref: ${{ github.ref }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Decide task (odds vs results)
        id: decide
        run: |
          set -e
          S="${{ github.event.schedule }}"
          TASK="${{ inputs.task }}"
          if [ "${{ github.event_name }}" = "schedule" ]; then
            if [ "$S" = "5 14 * * *" ] || [ "$S" = "5 13 * * *" ]; then
              echo "task=odds" >> $GITHUB_OUTPUT
            elif [ "$S" = "5 8 * * *" ] || [ "$S" = "5 7 * * *" ]; then
              echo "task=results" >> $GITHUB_OUTPUT
            else
              echo "Unknown schedule: $S"
              exit 1
            fi
          else
            # for push + workflow_dispatch, use the selected input (default "odds")
            echo "task=$TASK" >> $GITHUB_OUTPUT
          fi

      - name: Ensure data folder exists
        run: mkdir -p data

      - name: SQLite settings (CI-safe)
        run: |
          python - <<'PY'
          import sqlite3, os
          db = os.environ["DB_PATH"]
          con = sqlite3.connect(db)
          con.execute("PRAGMA journal_mode=DELETE;")
          con.execute("PRAGMA synchronous=FULL;")
          con.commit()
          con.close()
          print("Configured SQLite for CI:", db)
          PY

      # odds
      - name: Pull odds snapshot
        if: steps.decide.outputs.task == 'odds'
        env:
          ODDS_API_KEY: ${{ secrets.ODDS_API_KEY }}
        run: |
          python -m src.pipelines.run_odds_snapshot --sport basketball_nba --regions us --db "${DB_PATH}"

      - name: Debug DB counts (after odds)
        if: steps.decide.outputs.task == 'odds'
        run: |
          python - <<'PY'
          import os, sqlite3
          db = os.environ["DB_PATH"]
          con = sqlite3.connect(db)
          cur = con.cursor()
          tables = ["raw_moneyline_odds","raw_espn_game_results","game_id_map","fact_game_results_best_market"]
          print("DB:", db)
          for t in tables:
            try:
              n = cur.execute(f"select count(*) from {t}").fetchone()[0]
              print(f"{t}: {n}")
            except Exception as e:
              print(f"{t}: (missing) {e}")
          con.close()
          PY

      # results
      - name: Pull ESPN results (yesterday Chicago)
        if: steps.decide.outputs.task == 'results'
        run: |
          YDAY=$(TZ=America/Chicago date -d 'yesterday' +%Y%m%d)
          python -m src.pipelines.run_espn_results_pull --db "${DB_PATH}" --date "$YDAY"

      - name: Debug DB counts (after results pull)
        if: steps.decide.outputs.task == 'results'
        run: |
          python - <<'PY'
          import os, sqlite3
          db = os.environ["DB_PATH"]
          con = sqlite3.connect(db)
          cur = con.cursor()
          tables = ["raw_moneyline_odds","raw_espn_game_results","game_id_map","fact_game_results_best_market"]
          print("DB:", db)
          for t in tables:
            try:
              n = cur.execute(f"select count(*) from {t}").fetchone()[0]
              print(f"{t}: {n}")
            except Exception as e:
              print(f"{t}: (missing) {e}")
          con.close()
          PY

      - name: Run transforms (build fact tables)
        if: steps.decide.outputs.task == 'results'
        run: |
          python - <<'PY'
          import os
          from src.pipelines.run_full_pipeline import run_transforms
          run_transforms(os.environ["DB_PATH"], stake=1.0, calibration_step=0.05)
          PY

      - name: Debug DB counts (after transforms)
        if: steps.decide.outputs.task == 'results'
        run: |
          python - <<'PY'
          import os, sqlite3
          db = os.environ["DB_PATH"]
          con = sqlite3.connect(db)
          cur = con.cursor()
          tables = ["raw_moneyline_odds","raw_espn_game_results","game_id_map","fact_game_results_best_market"]
          print("DB:", db)
          for t in tables:
            try:
              n = cur.execute(f"select count(*) from {t}").fetchone()[0]
              print(f"{t}: {n}")
            except Exception as e:
              print(f"{t}: (missing) {e}")
          con.close()
          PY

      - name: Upload DB artifact
        uses: actions/upload-artifact@v4
        with:
          name: demo_odds-sqlite-${{ steps.decide.outputs.task }}
          path: ${{ env.DB_PATH }}

      - name: Commit DB if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add "${DB_PATH}" || true

          if git diff --cached --quiet; then
            echo "No DB changes to commit."
            exit 0
          fi

          if [ "${{ steps.decide.outputs.task }}" = "odds" ]; then
            git commit -m "chore: daily odds snapshot"
          else
            git commit -m "chore: daily results + transforms"
          fi

          # push back to the same branch that triggered this workflow
          git push origin HEAD:${{ github.ref_name }}
